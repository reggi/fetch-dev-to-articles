{
  "type_of": "article",
  "id": 1391495,
  "title": "Working with Unions Within Prisma",
  "description": "Unions help us define a value as one or more types. Sometimes this makes data easier to rationalize...",
  "readable_publish_date": "Apr 3",
  "slug": "working-with-unions-within-prisma-nm6",
  "path": "/reggi/working-with-unions-within-prisma-nm6",
  "url": "https://dev.to/reggi/working-with-unions-within-prisma-nm6",
  "comments_count": 0,
  "public_reactions_count": 0,
  "collection_id": null,
  "published_timestamp": "2023-04-03T02:39:03Z",
  "positive_reactions_count": 0,
  "cover_image": null,
  "social_image": "https://dev.to/social_previews/article/1391495.png",
  "canonical_url": "https://dev.to/reggi/working-with-unions-within-prisma-nm6",
  "created_at": "2023-03-07T06:57:44Z",
  "edited_at": null,
  "crossposted_at": null,
  "published_at": "2023-04-03T02:39:03Z",
  "last_comment_at": "2023-04-03T02:39:03Z",
  "reading_time_minutes": 5,
  "tag_list": "",
  "tags": [],
  "body_html": "<p>Unions help us define a value as one or more types. Sometimes this makes data easier to rationalize and makes it easier to represent our reality and the domains we're exploring. A common one I think about is how the United States uses the word <code>state</code>, where in Canada they use the word <code>province</code> to roughly describe the same thing. The union of the two being something like a <code>stateOrProvinceSpecificer: \"state\" | \"province\"</code>, a union of two constant strings.</p>\n\n<p>Sometimes our data just better fits as a structured union and even across primitive types like <code>boolean | number</code> or interface types like <code>article | photo</code>. Here's an deep-dive into unions within prisma. Prisma currently doesn’t support union types in the schema, but there are some ways we can work around this.</p>\n\n<p>Follow along with the repo here <a href=\"https://github.com/reggi/demo-prisma-union\">https://github.com/reggi/demo-prisma-union</a></p>\n\n<h2>\n  <a name=\"creating-the-schema\" href=\"#creating-the-schema\">\n  </a>\n  Creating the Schema\n</h2>\n\n<p>Touching on our <code>state</code> vs <code>province</code> example, and borrowing from this <a href=\"https://github.com/prisma/prisma/issues/2505#issuecomment-1045344408\">schema here</a>, let's say we wanted to create a <code>Place</code> table that is the union of a <code>City</code> or a <code>Country</code>. Perhaps we're building a map were the specificity doesn't need to matter, or a set of destinations. Here both are nullable which allows us to use them as unions, but also opens up the database to some other unintended circumstances, in this case both can be null, and both can be set 😬. We won't explore options for remedying this in this article, but there are other provisions that can be explored at the postgres level, as well as the API layer to ensure this doesn't happen.<br>\n</p>\n\n<div class=\"highlight js-code-highlight\">\n<pre class=\"highlight plaintext\"><code>model Place {\n  id           Int       @default(autoincrement()) @id\n  city         City?     @relation(fields: [cityId], references: [id])\n  cityId       Int?\n  country      Country?  @relation(fields: [countryId], references: [id])\n  countryId    Int?\n}\n</code></pre>\n<div class=\"highlight__panel js-actions-panel\">\n<div class=\"highlight__panel-action js-fullscreen-code-action\">\n    <svg xmlns=\"http://www.w3.org/2000/svg\" width=\"20px\" height=\"20px\" viewbox=\"0 0 24 24\" class=\"highlight-action crayons-icon highlight-action--fullscreen-on\"><title>Enter fullscreen mode</title>\n    <path d=\"M16 3h6v6h-2V5h-4V3zM2 3h6v2H4v4H2V3zm18 16v-4h2v6h-6v-2h4zM4 19h4v2H2v-6h2v4z\"></path>\n</svg>\n\n    <svg xmlns=\"http://www.w3.org/2000/svg\" width=\"20px\" height=\"20px\" viewbox=\"0 0 24 24\" class=\"highlight-action crayons-icon highlight-action--fullscreen-off\"><title>Exit fullscreen mode</title>\n    <path d=\"M18 7h4v2h-6V3h2v4zM8 9H2V7h4V3h2v6zm10 8v4h-2v-6h6v2h-4zM8 15v6H6v-4H2v-2h6z\"></path>\n</svg>\n\n</div>\n</div>\n</div>\n\n\n\n<p>We can expand out the <code>City</code> and <code>Country</code> models as well. Here I also added a bit of recursion a <code>City</code> also has an associated <code>Country</code>.<br>\n</p>\n\n<div class=\"highlight js-code-highlight\">\n<pre class=\"highlight plaintext\"><code>model City {\n  id           Int       @default(autoincrement()) @id\n  name         String    @unique\n  places       Place[]\n  country      Country   @relation(fields: [countryId], references: [id])\n  countryId    Int\n}\n\nmodel Country {\n  id           Int       @default(autoincrement()) @id\n  name         String    @unique\n  places       Place[]\n  cities       City[]\n}\n</code></pre>\n<div class=\"highlight__panel js-actions-panel\">\n<div class=\"highlight__panel-action js-fullscreen-code-action\">\n    <svg xmlns=\"http://www.w3.org/2000/svg\" width=\"20px\" height=\"20px\" viewbox=\"0 0 24 24\" class=\"highlight-action crayons-icon highlight-action--fullscreen-on\"><title>Enter fullscreen mode</title>\n    <path d=\"M16 3h6v6h-2V5h-4V3zM2 3h6v2H4v4H2V3zm18 16v-4h2v6h-6v-2h4zM4 19h4v2H2v-6h2v4z\"></path>\n</svg>\n\n    <svg xmlns=\"http://www.w3.org/2000/svg\" width=\"20px\" height=\"20px\" viewbox=\"0 0 24 24\" class=\"highlight-action crayons-icon highlight-action--fullscreen-off\"><title>Exit fullscreen mode</title>\n    <path d=\"M18 7h4v2h-6V3h2v4zM8 9H2V7h4V3h2v6zm10 8v4h-2v-6h6v2h-4zM8 15v6H6v-4H2v-2h6z\"></path>\n</svg>\n\n</div>\n</div>\n</div>\n\n\n\n<p>With all of this placed neatly within <code>schema.prisma</code> we can run <code>npx prisma migrate dev --name init</code> to migrate the schema and setup the database. I'm using a local postgres database. My <code>.env</code> file has something like this:<br>\n</p>\n\n<div class=\"highlight js-code-highlight\">\n<pre class=\"highlight shell\"><code><span class=\"nv\">DATABASE_URL</span><span class=\"o\">=</span><span class=\"s2\">\"postgresql://thomasreggi:thomasreggi@localhost:5432/prisma-demo?schema=public\"</span>\n</code></pre>\n<div class=\"highlight__panel js-actions-panel\">\n<div class=\"highlight__panel-action js-fullscreen-code-action\">\n    <svg xmlns=\"http://www.w3.org/2000/svg\" width=\"20px\" height=\"20px\" viewbox=\"0 0 24 24\" class=\"highlight-action crayons-icon highlight-action--fullscreen-on\"><title>Enter fullscreen mode</title>\n    <path d=\"M16 3h6v6h-2V5h-4V3zM2 3h6v2H4v4H2V3zm18 16v-4h2v6h-6v-2h4zM4 19h4v2H2v-6h2v4z\"></path>\n</svg>\n\n    <svg xmlns=\"http://www.w3.org/2000/svg\" width=\"20px\" height=\"20px\" viewbox=\"0 0 24 24\" class=\"highlight-action crayons-icon highlight-action--fullscreen-off\"><title>Exit fullscreen mode</title>\n    <path d=\"M18 7h4v2h-6V3h2v4zM8 9H2V7h4V3h2v6zm10 8v4h-2v-6h6v2h-4zM8 15v6H6v-4H2v-2h6z\"></path>\n</svg>\n\n</div>\n</div>\n</div>\n\n\n\n<h2>\n  <a name=\"seeding-the-database\" href=\"#seeding-the-database\">\n  </a>\n  Seeding the Database\n</h2>\n\n<p>Now that our database is ready, and the Prisma types have been generated we can seed the database with some dummy data. I've created a script that will create two cities, <code>New York</code> and <code>Berlin</code> and three countries <code>United States</code>, <code>France</code> and <code>Germany</code>. To seed the database run <code>npm tsx seed.ts</code>. </p>\n\n<h2>\n  <a name=\"querying-the-union\" href=\"#querying-the-union\">\n  </a>\n  Querying the Union\n</h2>\n\n<p>Now we can get to the juicy part. We can query the <code>Place</code> table and massage the Typescript types to more accurately represent the union we want to work with. We want to <code>include</code> both <code>City</code> and <code>Country</code> but also include the recursive aspect of <code>City.Country</code>, this can be down with an added nested include.<br>\n</p>\n\n<div class=\"highlight js-code-highlight\">\n<pre class=\"highlight typescript\"><code><span class=\"kd\">const</span> <span class=\"nx\">result</span> <span class=\"o\">=</span> <span class=\"k\">await</span> <span class=\"nx\">prisma</span><span class=\"p\">.</span><span class=\"nx\">place</span><span class=\"p\">.</span><span class=\"nx\">findFirst</span><span class=\"p\">({</span>\n  <span class=\"na\">where</span><span class=\"p\">:</span> <span class=\"p\">{</span> <span class=\"nx\">id</span> <span class=\"p\">},</span>\n  <span class=\"na\">include</span><span class=\"p\">:</span> <span class=\"p\">{</span>\n    <span class=\"na\">city</span><span class=\"p\">:</span> <span class=\"p\">{</span>\n      <span class=\"na\">include</span><span class=\"p\">:</span> <span class=\"p\">{</span>\n        <span class=\"na\">country</span><span class=\"p\">:</span> <span class=\"kc\">true</span>\n      <span class=\"p\">}</span>\n    <span class=\"p\">},</span>\n    <span class=\"na\">country</span><span class=\"p\">:</span> <span class=\"kc\">true</span>\n  <span class=\"p\">}</span>\n<span class=\"p\">})</span>\n</code></pre>\n<div class=\"highlight__panel js-actions-panel\">\n<div class=\"highlight__panel-action js-fullscreen-code-action\">\n    <svg xmlns=\"http://www.w3.org/2000/svg\" width=\"20px\" height=\"20px\" viewbox=\"0 0 24 24\" class=\"highlight-action crayons-icon highlight-action--fullscreen-on\"><title>Enter fullscreen mode</title>\n    <path d=\"M16 3h6v6h-2V5h-4V3zM2 3h6v2H4v4H2V3zm18 16v-4h2v6h-6v-2h4zM4 19h4v2H2v-6h2v4z\"></path>\n</svg>\n\n    <svg xmlns=\"http://www.w3.org/2000/svg\" width=\"20px\" height=\"20px\" viewbox=\"0 0 24 24\" class=\"highlight-action crayons-icon highlight-action--fullscreen-off\"><title>Exit fullscreen mode</title>\n    <path d=\"M18 7h4v2h-6V3h2v4zM8 9H2V7h4V3h2v6zm10 8v4h-2v-6h6v2h-4zM8 15v6H6v-4H2v-2h6z\"></path>\n</svg>\n\n</div>\n</div>\n</div>\n\n\n\n<p>What's super useful now that we've written this out is that prisma will automatically define the return type of the find when you hover over <code>result</code> you get this:<br>\n</p>\n\n<div class=\"highlight js-code-highlight\">\n<pre class=\"highlight typescript\"><code><span class=\"kd\">type</span> <span class=\"nx\">PlaceResult</span> <span class=\"o\">=</span> <span class=\"p\">(</span><span class=\"nx\">Prisma</span><span class=\"p\">.</span><span class=\"nx\">Place</span> <span class=\"o\">&amp;</span> <span class=\"p\">{</span>\n  <span class=\"na\">country</span><span class=\"p\">:</span> <span class=\"nx\">Prisma</span><span class=\"p\">.</span><span class=\"nx\">Country</span> <span class=\"o\">|</span> <span class=\"kc\">null</span><span class=\"p\">;</span>\n  <span class=\"nl\">city</span><span class=\"p\">:</span> <span class=\"p\">(</span><span class=\"nx\">Prisma</span><span class=\"p\">.</span><span class=\"nx\">City</span> <span class=\"o\">&amp;</span> <span class=\"p\">{</span>\n    <span class=\"na\">country</span><span class=\"p\">:</span> <span class=\"nx\">Prisma</span><span class=\"p\">.</span><span class=\"nx\">Country</span><span class=\"p\">;</span>\n  <span class=\"p\">})</span> <span class=\"o\">|</span> <span class=\"kc\">null</span><span class=\"p\">;</span>\n<span class=\"p\">})</span> <span class=\"o\">|</span> <span class=\"kc\">null</span>\n</code></pre>\n<div class=\"highlight__panel js-actions-panel\">\n<div class=\"highlight__panel-action js-fullscreen-code-action\">\n    <svg xmlns=\"http://www.w3.org/2000/svg\" width=\"20px\" height=\"20px\" viewbox=\"0 0 24 24\" class=\"highlight-action crayons-icon highlight-action--fullscreen-on\"><title>Enter fullscreen mode</title>\n    <path d=\"M16 3h6v6h-2V5h-4V3zM2 3h6v2H4v4H2V3zm18 16v-4h2v6h-6v-2h4zM4 19h4v2H2v-6h2v4z\"></path>\n</svg>\n\n    <svg xmlns=\"http://www.w3.org/2000/svg\" width=\"20px\" height=\"20px\" viewbox=\"0 0 24 24\" class=\"highlight-action crayons-icon highlight-action--fullscreen-off\"><title>Exit fullscreen mode</title>\n    <path d=\"M18 7h4v2h-6V3h2v4zM8 9H2V7h4V3h2v6zm10 8v4h-2v-6h6v2h-4zM8 15v6H6v-4H2v-2h6z\"></path>\n</svg>\n\n</div>\n</div>\n</div>\n\n\n\n<blockquote>\n<p>Note: Here I importer prisma as <code>import Prisma from '@prisma/client'</code> that way I keep prisma types scoped neatly within <code>Prisma.</code> and can define my own versions of all the types without confusion.</p>\n</blockquote>\n\n<p><a href=\"https://res.cloudinary.com/practicaldev/image/fetch/s--n7SmEEz5--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/v1/./type-hover.png\" class=\"article-body-image-wrapper\"><img src=\"https://res.cloudinary.com/practicaldev/image/fetch/s--n7SmEEz5--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/v1/./type-hover.png\" alt=\"shows typescript return type when hover\" loading=\"lazy\" width=\"\" height=\"\"></a></p>\n\n<p>Given that we want to explore a <code>Place</code> being a union of both <code>City</code> and <code>Country</code> this <code>result</code> type isn't exactly that. It's an object that can either have a <code>country</code> or a <code>city</code>, in fact it <strong>could</strong> have both or neither, which is problematic. We can fix this by wrapping the <code>create</code> and <code>find</code> functions and ensuring that when things are created in the database and when things are read out the structure of the data is as we'd expect. </p>\n\n<h2>\n  <a name=\"creating-a-typesafe-union\" href=\"#creating-a-typesafe-union\">\n  </a>\n  Creating a Typesafe Union\n</h2>\n\n<p>Because the example here of <code>City</code> and <code>Country</code> is a union of interfaces there's an advantage to knowing whether or not the Place is a <code>City</code> or a <code>Country</code> from a runtime perspective. One way to do this is to have add a <code>type</code> property to the interfaces. This will allow us to conditionally do different things depending on if it's a <code>City</code> or a <code>Country</code>. We can wrap the prisma types like this:<br>\n</p>\n\n<div class=\"highlight js-code-highlight\">\n<pre class=\"highlight typescript\"><code><span class=\"k\">import</span> <span class=\"nx\">Prisma</span> <span class=\"k\">from</span> <span class=\"dl\">'</span><span class=\"s1\">@prisma/client</span><span class=\"dl\">'</span>\n\n<span class=\"kd\">type</span> <span class=\"nx\">Country</span> <span class=\"o\">=</span> <span class=\"nx\">Prisma</span><span class=\"p\">.</span><span class=\"nx\">Country</span> <span class=\"o\">&amp;</span> <span class=\"p\">{</span> <span class=\"na\">type</span><span class=\"p\">:</span> <span class=\"dl\">'</span><span class=\"s1\">country</span><span class=\"dl\">'</span> <span class=\"p\">}</span>\n<span class=\"kd\">type</span> <span class=\"nx\">City</span> <span class=\"o\">=</span> <span class=\"nx\">Prisma</span><span class=\"p\">.</span><span class=\"nx\">City</span> <span class=\"o\">&amp;</span> <span class=\"p\">{</span> <span class=\"na\">type</span><span class=\"p\">:</span> <span class=\"dl\">'</span><span class=\"s1\">city</span><span class=\"dl\">'</span><span class=\"p\">,</span> <span class=\"na\">country</span><span class=\"p\">:</span> <span class=\"nx\">Country</span> <span class=\"p\">}</span>\n<span class=\"kd\">type</span> <span class=\"nx\">Place</span> <span class=\"o\">=</span> <span class=\"nx\">City</span> <span class=\"o\">|</span> <span class=\"nx\">Country</span>\n</code></pre>\n<div class=\"highlight__panel js-actions-panel\">\n<div class=\"highlight__panel-action js-fullscreen-code-action\">\n    <svg xmlns=\"http://www.w3.org/2000/svg\" width=\"20px\" height=\"20px\" viewbox=\"0 0 24 24\" class=\"highlight-action crayons-icon highlight-action--fullscreen-on\"><title>Enter fullscreen mode</title>\n    <path d=\"M16 3h6v6h-2V5h-4V3zM2 3h6v2H4v4H2V3zm18 16v-4h2v6h-6v-2h4zM4 19h4v2H2v-6h2v4z\"></path>\n</svg>\n\n    <svg xmlns=\"http://www.w3.org/2000/svg\" width=\"20px\" height=\"20px\" viewbox=\"0 0 24 24\" class=\"highlight-action crayons-icon highlight-action--fullscreen-off\"><title>Exit fullscreen mode</title>\n    <path d=\"M18 7h4v2h-6V3h2v4zM8 9H2V7h4V3h2v6zm10 8v4h-2v-6h6v2h-4zM8 15v6H6v-4H2v-2h6z\"></path>\n</svg>\n\n</div>\n</div>\n</div>\n\n\n\n<p>Here I'm importing prisma like this <code>import Prisma from '@prisma/client'</code> and not <code>import { Country, City, Place} from '@prisma/client'</code> because if we imported the types directly we'd be colliding with them in creating these new union-compatible alternatives.</p>\n\n<p>Voila! <code>Place</code> is now a perfect union of <code>City</code> and <code>Country</code>.</p>\n\n<p>Now that we have all the necessary types we can reuse the type return from Prisma's find <code>PlaceResult</code> that we defined above and transform it. This converts the object with <code>.city</code> or <code>.country</code> to a union without added <code>type</code> property which will come in handy in a bit.<br>\n</p>\n\n<div class=\"highlight js-code-highlight\">\n<pre class=\"highlight typescript\"><code><span class=\"kd\">function</span> <span class=\"nx\">transformPlaceUnion</span> <span class=\"p\">(</span><span class=\"nx\">result</span><span class=\"p\">:</span> <span class=\"nx\">PlaceResult</span><span class=\"p\">):</span> <span class=\"nx\">Place</span> <span class=\"o\">|</span> <span class=\"kc\">null</span> <span class=\"p\">{</span>\n  <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"nx\">result</span><span class=\"p\">?.</span><span class=\"nx\">city</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n    <span class=\"k\">return</span> <span class=\"p\">{</span>\n      <span class=\"p\">...</span><span class=\"nx\">result</span><span class=\"p\">.</span><span class=\"nx\">city</span><span class=\"p\">,</span>\n      <span class=\"na\">type</span><span class=\"p\">:</span> <span class=\"dl\">'</span><span class=\"s1\">city</span><span class=\"dl\">'</span><span class=\"p\">,</span>\n      <span class=\"na\">country</span><span class=\"p\">:</span> <span class=\"p\">{</span> <span class=\"na\">type</span><span class=\"p\">:</span> <span class=\"dl\">'</span><span class=\"s1\">country</span><span class=\"dl\">'</span><span class=\"p\">,</span> <span class=\"p\">...</span><span class=\"nx\">result</span><span class=\"p\">.</span><span class=\"nx\">city</span><span class=\"p\">.</span><span class=\"nx\">country</span> <span class=\"p\">}</span>\n    <span class=\"p\">}</span>\n  <span class=\"p\">}</span>\n  <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"nx\">result</span><span class=\"p\">?.</span><span class=\"nx\">country</span><span class=\"p\">)</span> <span class=\"k\">return</span> <span class=\"p\">{</span> <span class=\"p\">...</span><span class=\"nx\">result</span><span class=\"p\">.</span><span class=\"nx\">country</span><span class=\"p\">,</span> <span class=\"na\">type</span><span class=\"p\">:</span> <span class=\"dl\">'</span><span class=\"s1\">country</span><span class=\"dl\">'</span><span class=\"p\">}</span>\n  <span class=\"k\">return</span> <span class=\"kc\">null</span>\n<span class=\"p\">}</span>\n</code></pre>\n<div class=\"highlight__panel js-actions-panel\">\n<div class=\"highlight__panel-action js-fullscreen-code-action\">\n    <svg xmlns=\"http://www.w3.org/2000/svg\" width=\"20px\" height=\"20px\" viewbox=\"0 0 24 24\" class=\"highlight-action crayons-icon highlight-action--fullscreen-on\"><title>Enter fullscreen mode</title>\n    <path d=\"M16 3h6v6h-2V5h-4V3zM2 3h6v2H4v4H2V3zm18 16v-4h2v6h-6v-2h4zM4 19h4v2H2v-6h2v4z\"></path>\n</svg>\n\n    <svg xmlns=\"http://www.w3.org/2000/svg\" width=\"20px\" height=\"20px\" viewbox=\"0 0 24 24\" class=\"highlight-action crayons-icon highlight-action--fullscreen-off\"><title>Exit fullscreen mode</title>\n    <path d=\"M18 7h4v2h-6V3h2v4zM8 9H2V7h4V3h2v6zm10 8v4h-2v-6h6v2h-4zM8 15v6H6v-4H2v-2h6z\"></path>\n</svg>\n\n</div>\n</div>\n</div>\n\n\n\n<p>Now we can write a new <code>find</code> function putting all we've learned together:<br>\n</p>\n\n<div class=\"highlight js-code-highlight\">\n<pre class=\"highlight typescript\"><code><span class=\"k\">async</span> <span class=\"kd\">function</span> <span class=\"nx\">find</span> <span class=\"p\">(</span><span class=\"nx\">id</span><span class=\"p\">:</span> <span class=\"kr\">number</span><span class=\"p\">):</span> <span class=\"nb\">Promise</span><span class=\"o\">&lt;</span><span class=\"nx\">Place</span> <span class=\"o\">|</span> <span class=\"kc\">null</span><span class=\"o\">&gt;</span> <span class=\"p\">{</span>\n  <span class=\"kd\">const</span> <span class=\"nx\">result</span> <span class=\"o\">=</span> <span class=\"k\">await</span> <span class=\"nx\">prisma</span><span class=\"p\">.</span><span class=\"nx\">place</span><span class=\"p\">.</span><span class=\"nx\">findFirst</span><span class=\"p\">({</span>\n    <span class=\"na\">where</span><span class=\"p\">:</span> <span class=\"p\">{</span> <span class=\"nx\">id</span><span class=\"p\">},</span>\n    <span class=\"na\">include</span><span class=\"p\">:</span> <span class=\"p\">{</span>\n      <span class=\"na\">city</span><span class=\"p\">:</span> <span class=\"p\">{</span>\n        <span class=\"na\">include</span><span class=\"p\">:</span> <span class=\"p\">{</span>\n          <span class=\"na\">country</span><span class=\"p\">:</span> <span class=\"kc\">true</span>\n        <span class=\"p\">}</span>\n      <span class=\"p\">},</span>\n      <span class=\"na\">country</span><span class=\"p\">:</span> <span class=\"kc\">true</span>\n    <span class=\"p\">}</span>\n  <span class=\"p\">})</span>\n  <span class=\"k\">return</span> <span class=\"nx\">transformPlaceUnion</span><span class=\"p\">(</span><span class=\"nx\">result</span><span class=\"p\">)</span>\n<span class=\"p\">}</span>\n</code></pre>\n<div class=\"highlight__panel js-actions-panel\">\n<div class=\"highlight__panel-action js-fullscreen-code-action\">\n    <svg xmlns=\"http://www.w3.org/2000/svg\" width=\"20px\" height=\"20px\" viewbox=\"0 0 24 24\" class=\"highlight-action crayons-icon highlight-action--fullscreen-on\"><title>Enter fullscreen mode</title>\n    <path d=\"M16 3h6v6h-2V5h-4V3zM2 3h6v2H4v4H2V3zm18 16v-4h2v6h-6v-2h4zM4 19h4v2H2v-6h2v4z\"></path>\n</svg>\n\n    <svg xmlns=\"http://www.w3.org/2000/svg\" width=\"20px\" height=\"20px\" viewbox=\"0 0 24 24\" class=\"highlight-action crayons-icon highlight-action--fullscreen-off\"><title>Exit fullscreen mode</title>\n    <path d=\"M18 7h4v2h-6V3h2v4zM8 9H2V7h4V3h2v6zm10 8v4h-2v-6h6v2h-4zM8 15v6H6v-4H2v-2h6z\"></path>\n</svg>\n\n</div>\n</div>\n</div>\n\n\n\n<p>Now when we call this <code>find</code> we get a <code>place</code> variable that has the type <code>Place | null</code> and we can easily access that country only for <code>city</code>.<br>\n</p>\n\n<div class=\"highlight js-code-highlight\">\n<pre class=\"highlight typescript\"><code><span class=\"kd\">const</span> <span class=\"nx\">place</span> <span class=\"o\">=</span> <span class=\"k\">await</span> <span class=\"nx\">find</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">)</span>\n\n<span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"o\">!</span><span class=\"nx\">place</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n  <span class=\"nx\">console</span><span class=\"p\">.</span><span class=\"nx\">log</span><span class=\"p\">(</span><span class=\"dl\">'</span><span class=\"s1\">Place not found</span><span class=\"dl\">'</span><span class=\"p\">)</span>\n  <span class=\"k\">return</span>\n<span class=\"p\">}</span> <span class=\"k\">else</span> <span class=\"p\">{</span>\n  <span class=\"nx\">console</span><span class=\"p\">.</span><span class=\"nx\">log</span><span class=\"p\">(</span><span class=\"nx\">place</span><span class=\"p\">.</span><span class=\"nx\">name</span><span class=\"p\">)</span>\n  <span class=\"nx\">console</span><span class=\"p\">.</span><span class=\"nx\">log</span><span class=\"p\">(</span><span class=\"nx\">place</span><span class=\"p\">.</span><span class=\"kd\">type</span><span class=\"p\">)</span>\n<span class=\"p\">}</span>\n\n<span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"nx\">place</span><span class=\"p\">.</span><span class=\"kd\">type</span> <span class=\"o\">===</span> <span class=\"dl\">'</span><span class=\"s1\">city</span><span class=\"dl\">'</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n  <span class=\"c1\">// ✅ type safety works here</span>\n  <span class=\"nx\">console</span><span class=\"p\">.</span><span class=\"nx\">log</span><span class=\"p\">(</span><span class=\"nx\">place</span><span class=\"p\">.</span><span class=\"nx\">country</span><span class=\"p\">.</span><span class=\"nx\">name</span><span class=\"p\">)</span>\n<span class=\"p\">}</span>\n\n<span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"nx\">place</span><span class=\"p\">.</span><span class=\"kd\">type</span> <span class=\"o\">===</span> <span class=\"dl\">'</span><span class=\"s1\">country</span><span class=\"dl\">'</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n  <span class=\"c1\">// ❌ type safety works here and will throw error country doesn't have a country</span>\n  <span class=\"c1\">// console.log(place.country.name)</span>\n<span class=\"p\">}</span>\n</code></pre>\n<div class=\"highlight__panel js-actions-panel\">\n<div class=\"highlight__panel-action js-fullscreen-code-action\">\n    <svg xmlns=\"http://www.w3.org/2000/svg\" width=\"20px\" height=\"20px\" viewbox=\"0 0 24 24\" class=\"highlight-action crayons-icon highlight-action--fullscreen-on\"><title>Enter fullscreen mode</title>\n    <path d=\"M16 3h6v6h-2V5h-4V3zM2 3h6v2H4v4H2V3zm18 16v-4h2v6h-6v-2h4zM4 19h4v2H2v-6h2v4z\"></path>\n</svg>\n\n    <svg xmlns=\"http://www.w3.org/2000/svg\" width=\"20px\" height=\"20px\" viewbox=\"0 0 24 24\" class=\"highlight-action crayons-icon highlight-action--fullscreen-off\"><title>Exit fullscreen mode</title>\n    <path d=\"M18 7h4v2h-6V3h2v4zM8 9H2V7h4V3h2v6zm10 8v4h-2v-6h6v2h-4zM8 15v6H6v-4H2v-2h6z\"></path>\n</svg>\n\n</div>\n</div>\n</div>\n\n\n\n<h2>\n  <a name=\"conclusion\" href=\"#conclusion\">\n  </a>\n  Conclusion\n</h2>\n\n<p>Unions help us structure our data to be more in alignment with how we see the world, and how our domain models function. By making two columns nullable and transforming the return value from the database we can  explore unions in Typescript. </p>\n\n",
  "body_markdown": "Unions help us define a value as one or more types. Sometimes this makes data easier to rationalize and makes it easier to represent our reality and the domains we're exploring. A common one I think about is how the United States uses the word `state`, where in Canada they use the word `province` to roughly describe the same thing. The union of the two being something like a `stateOrProvinceSpecificer: \"state\" | \"province\"`, a union of two constant strings.\n\nSometimes our data just better fits as a structured union and even across primitive types like `boolean | number` or interface types like `article | photo`. Here's an deep-dive into unions within prisma. Prisma currently doesn’t support union types in the schema, but there are some ways we can work around this.\n\nFollow along with the repo here https://github.com/reggi/demo-prisma-union\n\n## Creating the Schema\n\nTouching on our `state` vs `province` example, and borrowing from this [schema here](https://github.com/prisma/prisma/issues/2505#issuecomment-1045344408), let's say we wanted to create a `Place` table that is the union of a `City` or a `Country`. Perhaps we're building a map were the specificity doesn't need to matter, or a set of destinations. Here both are nullable which allows us to use them as unions, but also opens up the database to some other unintended circumstances, in this case both can be null, and both can be set 😬. We won't explore options for remedying this in this article, but there are other provisions that can be explored at the postgres level, as well as the API layer to ensure this doesn't happen.\n\n```prisma\nmodel Place {\n  id           Int       @default(autoincrement()) @id\n  city         City?     @relation(fields: [cityId], references: [id])\n  cityId       Int?\n  country      Country?  @relation(fields: [countryId], references: [id])\n  countryId    Int?\n}\n```\n\nWe can expand out the `City` and `Country` models as well. Here I also added a bit of recursion a `City` also has an associated `Country`.\n\n```prisma\nmodel City {\n  id           Int       @default(autoincrement()) @id\n  name         String    @unique\n  places       Place[]\n  country      Country   @relation(fields: [countryId], references: [id])\n  countryId    Int\n}\n\nmodel Country {\n  id           Int       @default(autoincrement()) @id\n  name         String    @unique\n  places       Place[]\n  cities       City[]\n}\n```\n\nWith all of this placed neatly within `schema.prisma` we can run `npx prisma migrate dev --name init` to migrate the schema and setup the database. I'm using a local postgres database. My `.env` file has something like this:\n\n```shell\nDATABASE_URL=\"postgresql://thomasreggi:thomasreggi@localhost:5432/prisma-demo?schema=public\"\n```\n\n## Seeding the Database\n\nNow that our database is ready, and the Prisma types have been generated we can seed the database with some dummy data. I've created a script that will create two cities, `New York` and `Berlin` and three countries `United States`, `France` and `Germany`. To seed the database run `npm tsx seed.ts`. \n\n## Querying the Union\n\nNow we can get to the juicy part. We can query the `Place` table and massage the Typescript types to more accurately represent the union we want to work with. We want to `include` both `City` and `Country` but also include the recursive aspect of `City.Country`, this can be down with an added nested include.\n\n```ts\nconst result = await prisma.place.findFirst({\n  where: { id },\n  include: {\n    city: {\n      include: {\n        country: true\n      }\n    },\n    country: true\n  }\n})\n```\n\nWhat's super useful now that we've written this out is that prisma will automatically define the return type of the find when you hover over `result` you get this:\n\n```ts\ntype PlaceResult = (Prisma.Place & {\n  country: Prisma.Country | null;\n  city: (Prisma.City & {\n    country: Prisma.Country;\n  }) | null;\n}) | null\n```\n\n> Note: Here I importer prisma as `import Prisma from '@prisma/client'` that way I keep prisma types scoped neatly within `Prisma.` and can define my own versions of all the types without confusion.\n\n![shows typescript return type when hover](./type-hover.png)\n\nGiven that we want to explore a `Place` being a union of both `City` and `Country` this `result` type isn't exactly that. It's an object that can either have a `country` or a `city`, in fact it __could__ have both or neither, which is problematic. We can fix this by wrapping the `create` and `find` functions and ensuring that when things are created in the database and when things are read out the structure of the data is as we'd expect. \n\n## Creating a Typesafe Union\n\nBecause the example here of `City` and `Country` is a union of interfaces there's an advantage to knowing whether or not the Place is a `City` or a `Country` from a runtime perspective. One way to do this is to have add a `type` property to the interfaces. This will allow us to conditionally do different things depending on if it's a `City` or a `Country`. We can wrap the prisma types like this:\n\n```ts\nimport Prisma from '@prisma/client'\n\ntype Country = Prisma.Country & { type: 'country' }\ntype City = Prisma.City & { type: 'city', country: Country }\ntype Place = City | Country\n```\n\nHere I'm importing prisma like this `import Prisma from '@prisma/client'` and not `import { Country, City, Place} from '@prisma/client'` because if we imported the types directly we'd be colliding with them in creating these new union-compatible alternatives.\n\nVoila! `Place` is now a perfect union of `City` and `Country`.\n\nNow that we have all the necessary types we can reuse the type return from Prisma's find `PlaceResult` that we defined above and transform it. This converts the object with `.city` or `.country` to a union without added `type` property which will come in handy in a bit.\n\n```ts\nfunction transformPlaceUnion (result: PlaceResult): Place | null {\n  if (result?.city) {\n    return {\n      ...result.city,\n      type: 'city',\n      country: { type: 'country', ...result.city.country }\n    }\n  }\n  if (result?.country) return { ...result.country, type: 'country'}\n  return null\n}\n```\n\nNow we can write a new `find` function putting all we've learned together:\n\n```ts\nasync function find (id: number): Promise<Place | null> {\n  const result = await prisma.place.findFirst({\n    where: { id},\n    include: {\n      city: {\n        include: {\n          country: true\n        }\n      },\n      country: true\n    }\n  })\n  return transformPlaceUnion(result)\n}\n```\n\nNow when we call this `find` we get a `place` variable that has the type `Place | null` and we can easily access that country only for `city`.\n\n```ts\nconst place = await find(1)\n\nif (!place) {\n  console.log('Place not found')\n  return\n} else {\n  console.log(place.name)\n  console.log(place.type)\n}\n\nif (place.type === 'city') {\n  // ✅ type safety works here\n  console.log(place.country.name)\n}\n\nif (place.type === 'country') {\n  // ❌ type safety works here and will throw error country doesn't have a country\n  // console.log(place.country.name)\n}\n```\n\n## Conclusion \n\nUnions help us structure our data to be more in alignment with how we see the world, and how our domain models function. By making two columns nullable and transforming the return value from the database we can  explore unions in Typescript. ",
  "user": {
    "name": "Thomas Reggi",
    "username": "reggi",
    "twitter_username": "thomasreggi",
    "github_username": "reggi",
    "user_id": 274085,
    "website_url": "https://indieweb.social/@thomasreggi",
    "profile_image": "https://res.cloudinary.com/practicaldev/image/fetch/s--tHfYzZxa--/c_fill,f_auto,fl_progressive,h_640,q_auto,w_640/https://dev-to-uploads.s3.amazonaws.com/uploads/user/profile_image/274085/29eb3cad-1335-49b1-9f1d-35b2ee3717b0.jpeg",
    "profile_image_90": "https://res.cloudinary.com/practicaldev/image/fetch/s--qhQltV8A--/c_fill,f_auto,fl_progressive,h_90,q_auto,w_90/https://dev-to-uploads.s3.amazonaws.com/uploads/user/profile_image/274085/29eb3cad-1335-49b1-9f1d-35b2ee3717b0.jpeg"
  }
}